#!groovy

node("vsphere-vpn-1") {
  def rootPath = "/root/go/src/github.com/rancher/rancher/"
  def workPath = "/root/go/src/github.com/rancher/rancher/tests/v2/validation/"
  def jobName = "${JOB_NAME}"
  if (jobName.contains('/')) {
    jobNames = jobName.split('/')
    jobName = jobNames[jobNames.size() - 1]
  }
  def golangTestContainer = "${jobName}${env.BUILD_NUMBER}-golangtest"
  def buildTestContainer = "${jobName}${env.BUILD_NUMBER}-buildtest"
  def configGeneratorContainer = "${jobName}${env.BUILD_NUMBER}_generator"
  def cleanupTestContainer = "${jobName}${env.BUILD_NUMBER}-cleanuptest"
  def imageName = "rancher-recurring-runs-validation-${jobName}${env.BUILD_NUMBER}"
  def validationVolume = "RecurringRunsSharedVolume-${jobName}${env.BUILD_NUMBER}"
  def testsDir = "/root/go/src/github.com/rancher/rancher/tests/v2/validation/"
  def configsDir = "cattle-configs"
  def patchedConfigsDir = "patched-cattle-configs"
  def testResultsOut = "results.xml"
  def envFile = ".env"
  def rancherConfig = "rancher_env.config"
  def branch = "release/v2.10"
  def corralBranch = "main"
  def config = env.CONFIG
  def filename = "config.yaml"
  def individualJob = "$jobName"
  individualJob = "${individualJob}-individual-job"

  if ("${env.BRANCH}" != "null" && "${env.BRANCH}" != "") {
    branch = "${env.BRANCH}"
  }

  if ("${env.RANCHER_CORRAL_PACKAGES_REPO_BRANCH}" != "null" && "${env.RANCHER_CORRAL_PACKAGES_REPO_BRANCH}" != "") {
    corralBranch = "${env.RANCHER_CORRAL_PACKAGES_REPO_BRANCH}"
  }

  def rancherRepo = scm.getUserRemoteConfigs()[0].getUrl()
  if ("${env.REPO}" != "null" && "${env.REPO}" != "") {
    rancherRepo = "${env.REPO}"
  }

  def corralRepo = scm.getUserRemoteConfigs()[1].getUrl()
  corralRepo = "https://github.com/slickwarren/suse-garage.git"

  def timeout = "60m"
  if ("${env.TIMEOUT}" != "null" && "${env.TIMEOUT}" != "") {
    timeout = "${env.TIMEOUT}"
  }

  def configFiles = []
  wrap([$class: 'AnsiColorBuildWrapper', 'colorMapName': 'XTerm', 'defaultFg': 2, 'defaultBg': 1]) {
    withFolderProperties {
      paramsMap = []
      params.each {
        if (it.value && it.value.trim() != "") {
          paramsMap << "$it.key=$it.value"
        }
      }
      withCredentials([string(credentialsId: 'AWS_ACCESS_KEY_ID', variable: 'AWS_ACCESS_KEY_ID'),
        string(credentialsId: 'AWS_SECRET_ACCESS_KEY', variable: 'AWS_SECRET_ACCESS_KEY'),
        string(credentialsId: 'AWS_ACCESS_KEY_ID', variable: 'RANCHER_EKS_ACCESS_KEY'),
        string(credentialsId: 'AWS_SECRET_ACCESS_KEY', variable: 'RANCHER_EKS_SECRET_KEY'),
        string(credentialsId: 'AWS_SSH_PEM_KEY', variable: 'AWS_SSH_PEM_KEY'),
        string(credentialsId: 'AWS_SSH_PEM_KEY', variable: 'AWS_SSH_PEM_KEY'),
        string(credentialsId: 'AWS_SSH_RSA_KEY', variable: 'AWS_SSH_RSA_KEY'),
        string(credentialsId: 'AWS_RSA_KEY_NAME', variable: 'AWS_RSA_KEY_NAME'),
        string(credentialsId: 'RANCHER_SSH_KEY', variable: 'RANCHER_SSH_KEY'),
        string(credentialsId: 'RANCHER_REGISTRY_USER_NAME', variable: 'RANCHER_REGISTRY_USER_NAME'),
        string(credentialsId: 'RANCHER_REGISTRY_PASSWORD', variable: 'RANCHER_REGISTRY_PASSWORD'),
        string(credentialsId: 'ADMIN_PASSWORD', variable: 'ADMIN_PASSWORD'),
        string(credentialsId: 'USER_PASSWORD', variable: 'USER_PASSWORD'),
        string(credentialsId: 'RANCHER_VALID_TLS_CERT', variable: 'RANCHER_VALID_TLS_CERT'),
        string(credentialsId: 'RANCHER_VALID_TLS_KEY', variable: 'RANCHER_VALID_TLS_KEY'),
        string(credentialsId: 'RANCHER_BYO_TLS_CERT', variable: 'RANCHER_BYO_TLS_CERT'),
        string(credentialsId: 'RANCHER_BYO_TLS_KEY', variable: 'RANCHER_BYO_TLS_KEY'),
        string(credentialsId: 'SLACK_WEBHOOK', variable: 'SLACK_WEBHOOK'),
      ]) {

        withEnv(paramsMap) {
          stage('Checkout') {
            deleteDir()
            dir("./rancher") {
              checkout([
                $class: 'GitSCM',
                branches: [
                  [name: "*/${branch}"]
                ],
                extensions: scm.extensions + [
                  [$class: 'CleanCheckout']
                ],
                userRemoteConfigs: [
                  [url: rancherRepo]
                ]
              ])
            }
            dir('./') {
              echo "cloning corral-packages repo"

              dir('./suse-garage') {
                checkout([
                  $class: 'GitSCM',
                  branches: [
                    [name: "*/${corralBranch}"]
                  ],
                  extensions: scm.extensions + [
                    [$class: 'CleanCheckout']
                  ],
                  userRemoteConfigs: [
                    [url: corralRepo]
                  ]
                ])
              }
            }
          }
          def rancherURL = ""
          def rancherToken = ""
          def harvesterURL = ""
          def harvesterToken = ""
          dir("./") {
            stage('Configure and Build') {
              sh returnStdout: true, script: 'wget -qO ./yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64'
              sh returnStdout: true, script: 'chmod a+x ./yq'
              config = config.replace('${AWS_SECRET_ACCESS_KEY}', env.AWS_SECRET_ACCESS_KEY)
              config = config.replace('${AWS_ACCESS_KEY_ID}', env.AWS_ACCESS_KEY_ID)
              config = config.replace('${AWS_IAM_PROFILE}', env.AWS_IAM_PROFILE)
              config = config.replace('${AWS_REGION}', env.AWS_REGION)
              config = config.replace('${AWS_VPC}', env.AWS_VPC)
              config = config.replace('${AWS_SECURITY_GROUPS}', env.AWS_SECURITY_GROUPS)
              config = config.replace('${ADMIN_PASSWORD}', env.ADMIN_PASSWORD)

              if (env.AWS_SSH_PEM_KEY && env.AWS_SSH_KEY_NAME) {
                dir("./rancher/tests/v2/validation/.ssh") {
                  def decoded = new String(AWS_SSH_PEM_KEY.decodeBase64())
                  writeFile file: AWS_SSH_KEY_NAME, text: decoded
                }
              }

              dir("./tests/v2/validation/.ssh") {
                def decodedRsa = new String(AWS_SSH_RSA_KEY.decodeBase64())
                writeFile file: AWS_RSA_KEY_NAME, text: decodedRsa
              }

              dir("./rancher/tests/v2/validation") {
                writeFile file: filename, text: config
                env.CATTLE_TEST_CONFIG = "${workPath}${filename}"
              }

              dir("./suse-garage/terraform/${env.PROVIDER}/") {
                writeFile file: "terraform.tfvars", text: env.TF_VARS
                writeFile file: "local.yaml", text: env.HARVESTER_KUBECONFIG
              }

              dir("./suse-garage/rancher-local/k3s-ha/") {
                writeFile file: "e2e.env", text: env.LOCAL_CLUSTER_VARS
              }

              dir("./") {
                def harvesterConfigPath = "./suse-garage/terraform/${env.PROVIDER}/local.yaml"
                harvesterURL = sh(
                      script: "./yq '.clusters.[0].cluster.server'  ${harvesterConfigPath}",
                      returnStdout: true
                    ).trim().split('/k8s/')[0].split('/')[-1].trim()
                harvesterToken = sh(
                      script: "./yq '.users.[0].user.token'  ${harvesterConfigPath}",
                      returnStdout: true
                    ).trim()
                    
                sh "./rancher/tests/v2/validation/configure.sh"
                sh "docker build . -f ./rancher/tests/v2/validation/Dockerfile.vsphere -t ${imageName}"
              }
            }
            stage("Bootstrap rancher cluster") {
              try {
                def rancher_output = sh(script:"docker run --name ${buildTestContainer} -t -e PROVIDER=$env.PROVIDER " +
                  "${imageName}  sh -c \"${rootPath}../../rancherlabs/suse-garage/rancher-local/k3s-ha/e2e_create_rancher.sh\"", returnStdout: true).trim()
                rancher_output = rancher_output.split('\n')
                rancherURL = rancher_output[-3].split('/')[-1].trim()
                rancherToken = rancher_output[-1].trim()

              } catch (err) {
                sh "docker run --volumes-from ${buildTestContainer} --name ${buildTestContainer}-cleanup -t -e PROVIDER=$env.PROVIDER " +
                  "${imageName}  sh -c \"cd ${rootPath}../../rancherlabs/suse-garage/terraform/$env.PROVIDER && rm .terraform.lock.hcl && terraform init && terraform destroy -auto-approve\""
                sh "docker stop ${buildTestContainer}"
                sh "docker rm -v ${buildTestContainer}"
                error "Build Environment had failures. Good luck!"
              }
            }
            try {
              stage('Generate child configs') {
                sh "docker run --volumes-from ${buildTestContainer} --name ${configGeneratorContainer} -t -e CATTLE_TEST_CONFIG=\$CATTLE_TEST_CONFIG " +
                  "${imageName} sh -c \"${workPath}pipeline/releaseupgrade/releaseupgrade.sh\""

                sh "docker cp ${configGeneratorContainer}:${rootPath}${configsDir}/ ."

                def configs = sh(script: "ls -1 ./${configsDir}", returnStdout: true).split()

                for (int i = 0; i < configs.size(); i++) {
                  def configName = configs[i]
                  echo "pushing ${configName} to the global variable"
                  configFiles << "${configName}"
                }

                println "Building the image again with the config files"
                sh "./rancher/tests/v2/validation/configure.sh"
                sh "docker build . -f ./rancher/tests/v2/validation/Dockerfile.vsphere -t ${imageName}"
              }
              stage('Deploys child clusters') {
                try {
                  jobs = [: ]

                  configFiles.each {
                    def configPath = "./${configsDir}/$it"
                    def absoluteConfigPath = "${rootPath}${configsDir}/$it"

                    def testCase = sh(
                      script: "./yq '.testCases.provisioningTestCase'  ${configPath}",
                      returnStdout: true
                    ).trim()

                    def testPackage = sh(
                      script: "./yq '.testCases.provisioningTestPackage'  ${configPath}",
                      returnStdout: true
                    ).trim()

                    jobs["$it-provisioning"] = {
                      stage("Parallel Provisioning: $it") {
                        def containerName = "${jobName}${env.BUILD_NUMBER}_$it-provisioning"
                        try {
                          sh "docker run --volumes-from ${buildTestContainer} --name ${containerName} -t -e CATTLE_TEST_CONFIG=\"${absoluteConfigPath}\" " +
                            "${imageName} sh -c \"gotestsum --format standard-verbose --packages=\"${testsDir}${testPackage}\" --junitfile ${testResultsOut} -- -tags=validation ${testCase} -timeout=\"60m\" -v\""

                          dir("./${patchedConfigsDir}") {
                            sh "docker cp ${containerName}:${rootPath}${configsDir}/$it ."
                          }
                        } catch (err) {
                          sh "docker stop ${containerName}"
                          sh "docker rm -v ${containerName}"
                        }

                        sh "docker stop ${containerName}"
                        sh "docker rm -v ${containerName}"
                      }
                    }
                  }
                  parallel jobs
                } catch (err) {
                  echo "Provisioning tests had failures: " + err
                }
              }
              stage('Run Tests') {
                try {
                  jobs = [: ]

                  // copy updated config file from the build test container
                  sh "docker cp ${buildTestContainer}:${workPath}${filename} ./"

                  def mainRancherConfigPath = "./${filename}"

                  sh "./yq e '.harvester.host = \"${harvesterURL}.sslip.io\"' -i ${mainRancherConfigPath}"
                  sh "./yq e '.harvester.adminToken = \"${harvesterToken}\"' -i ${mainRancherConfigPath}"

                  sh "./yq e '.rancher.host = \"${rancherURL}\"' -i ${mainRancherConfigPath}"
                  sh "./yq e '.rancher.adminToken = \"${rancherToken}\"' -i ${mainRancherConfigPath}"

                  sh "./yq e '.rancher.cleanup = true' -i ${mainRancherConfigPath}"
                  configFiles.each {
                    try {
                      def configPath = "./${patchedConfigsDir}/$it"

                      def tags = sh(
                        script: "./yq '.testCases.tags'  ${configPath}",
                        returnStdout: true
                      ).trim()

                      def runFlag = sh(
                        script: "./yq '.testCases.runFlag'  ${configPath}",
                        returnStdout: true
                      ).trim()

                      def clusterName = sh(
                        script: "./yq '.rancher.clusterName' ${configPath}",
                        returnStdout: true
                      ).trim()

                      sh "./yq e '.rancher.clusterName = \"${clusterName}\"' -i ${mainRancherConfigPath}"

                      def configYaml = readFile(file: "${mainRancherConfigPath}")

                      def goValidationParams = [
                        string(name: 'TIMEOUT', value: timeout),
                        text(name: 'CONFIG', value: configYaml),
                        string(name: 'REPO', value: "${rancherRepo}"),
                        string(name: 'BRANCH', value: "${branch}"),
                        string(name: 'TEST_PACKAGE', value: "${env.TEST_PACKAGE}"),
                        string(name: 'GOTEST_TESTCASE', value: "${runFlag} -p 1"),
                        string(name: 'TAGS', value: tags),
                      ]

                      jobs["$it-test-validation"] = {
                        build job: individualJob,
                        parameters: goValidationParams
                      }
                    } catch (err) {
                      echo "Test Validation $it had failures: " + err
                    }
                  }

                  if ("${env.TAGS}" != "") {
                    sh "./yq e 'del(.provisioningInput.machinePools)' -i ${mainRancherConfigPath}"
                    sh "./yq e 'del(.provisioningInput.nodePools)' -i ${mainRancherConfigPath}"
                    def configYaml = readFile(file: "${mainRancherConfigPath}")

                    def goValidationParams = [
                      string(name: 'TIMEOUT', value: timeout),
                      text(name: 'CONFIG', value: configYaml),
                      string(name: 'REPO', value: "${rancherRepo}"),
                      string(name: 'BRANCH', value: "${branch}"),
                      string(name: 'TEST_PACKAGE', value: "${env.TEST_PACKAGE}"),
                      string(name: 'TAGS', value: "${env.TAGS}"),
                      string(name: 'GOTEST_TESTCASE', value: "${env.GOTEST_TESTCASE} -p 1"),
                    ]

                    jobs["provisioning-test-validation"] = {
                      build job: individualJob,
                      parameters: goValidationParams
                    }

                  }
                  parallel jobs
                } catch (err) {
                  echo "Test validations had failures: " + err
                  sh "docker run --volumes-from ${buildTestContainer} --name ${buildTestContainer}-cleanup -t -e PROVIDER=$env.PROVIDER " +
                    "${imageName}  sh -c \"cd ${rootPath}../../rancherlabs/suse-garage/terraform/$env.PROVIDER && rm .terraform.lock.hcl && terraform init &&  terraform destroy -auto-approve\""
                  sh "docker stop ${buildTestContainer}"
                  sh "docker rm -v ${buildTestContainer}"
                  error "Build Environment had failures. Good luck!"
                }
              }
            } catch (err) {
              echo "Failures " + err
            }

            stage('Cleanup Rancher Environment') {
              if ("${env.CLEANUP_RANCHER}" == "True" || "${env.CLEANUP_RANCHER}" == "true") {
                try {
                  sh "docker run --volumes-from ${buildTestContainer} --name ${buildTestContainer}-cleanup1 -t -e PROVIDER=$env.PROVIDER " +
                    "${imageName}  sh -c \"cd ${rootPath}../../rancherlabs/suse-garage/terraform/$env.PROVIDER && rm .terraform.lock.hcl && terraform init &&  terraform destroy -auto-approve\""
                  sh "docker run --volumes-from ${buildTestContainer}-cleanup2 --name ${cleanupTestContainer} -t --env-file ${envFile} " +
                    "${imageName} sh -c \"${workPath}pipeline/scripts/rancher_cleanup.sh\""
                } catch (err) {
                  sh "docker stop ${buildTestContainer}"
                  sh "docker rm -v ${buildTestContainer}"
                  sh "docker rmi -f ${imageName}"
                  error "Cleanup had failures."
                }
              }
            }
            // stage('Clean Up Images and Volume') {
            //   echo 'Cleaning test images and volume.'
            //   sh "docker stop ${buildTestContainer}"
            //   sh "docker rm -v ${buildTestContainer}"
            //   sh "docker stop ${configGeneratorContainer}"
            //   sh "docker rm -v ${configGeneratorContainer}"
            //   if ("${env.CLEANUP_RANCHER}" == "True" || "${env.CLEANUP_RANCHER}" == "true") {
            //     sh "docker stop ${cleanupTestContainer}"
            //     sh "docker rm -v ${cleanupTestContainer}"
            //   }
            //   sh "docker rmi -f ${imageName}"
            //   sh "docker volume rm -f ${validationVolume}"
            // }
          } // dir 
        } // withEnv
      } // creds
    } // folder properties
  } // wrap 
  
} // node